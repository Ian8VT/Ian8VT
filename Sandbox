from qgis.core import QgsProcessing
from qgis.core import QgsProcessingAlgorithm
from qgis.core import QgsProcessingMultiStepFeedback
from qgis.core import QgsProcessingParameterFeatureSource
from qgis.core import QgsProcessingParameterString
from qgis.core import QgsProcessingParameterVectorLayer
from qgis.core import QgsProcessingParameterFeatureSink
import processing


class DistanceAndDirectionFromPoint(QgsProcessingAlgorithm):

    def initAlgorithm(self, config=None):
        self.addParameter(QgsProcessingParameterFeatureSource('citycenter', 'City Center', types=[QgsProcessing.TypeVectorAnyGeometry], defaultValue=None))
        self.addParameter(QgsProcessingParameterString('fieldnameprefix', 'Field Name Prefix', multiLine=False, defaultValue='CBD'))
        self.addParameter(QgsProcessingParameterVectorLayer('inputfeautres', 'Input Feautres', types=[QgsProcessing.TypeVectorPolygon], defaultValue=None))
        self.addParameter(QgsProcessingParameterFeatureSink('DirectionDistanceOutput', 'Direction Distance Output', type=QgsProcessing.TypeVectorAnyGeometry, createByDefault=True, defaultValue=None))

    def processAlgorithm(self, parameters, context, model_feedback):
        # Use a multi-step feedback, so that individual child algorithm progress reports are adjusted for the
        # overall progress through the model
        feedback = QgsProcessingMultiStepFeedback(4, model_feedback)
        results = {}
        outputs = {}

        # Centroids
        alg_params = {
            'ALL_PARTS': False,
            'INPUT': parameters['citycenter'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['Centroids'] = processing.run('native:centroids', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(1)
        if feedback.isCanceled():
            return {}

        # Mean coordinate(s)
        alg_params = {
            'INPUT': outputs['Centroids']['OUTPUT'],
            'UID': None,
            'WEIGHT': None,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['MeanCoordinates'] = processing.run('native:meancoordinates', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(2)
        if feedback.isCanceled():
            return {}

        # Field calculator (distance)
        alg_params = {
            'FIELD_LENGTH': 10,
            'FIELD_NAME': QgsExpression(' concat ( @fieldnameprefix , 'Dist')').evaluate(),
            'FIELD_PRECISION': 3,
            'FIELD_TYPE': 0,
            'FORMULA': 'distance(centroid($geometry), \r\n make_point(  @Mean_coordinate_s__OUTPUT_maxx  ,  @Mean_coordinate_s__OUTPUT_maxy ))',
            'INPUT': parameters['inputfeautres'],
            'NEW_FIELD': False,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['FieldCalculatorDistance'] = processing.run('qgis:fieldcalculator', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(3)
        if feedback.isCanceled():
            return {}

        # Field calculator (direction)
        alg_params = {
            'FIELD_LENGTH': 10,
            'FIELD_NAME': QgsExpression(' concat(  @fieldnameprefix , 'DIR')
 ').evaluate(),
            'FIELD_PRECISION': 3,
            'FIELD_TYPE': 0,
            'FORMULA': 'degrees(azimuth( make_point(  @Mean_coordinate_s__OUTPUT_maxx , @Mean_coordinate_s__OUTPUT_maxy ), centroid($geometry)))',
            'INPUT': outputs['FieldCalculatorDistance']['OUTPUT'],
            'NEW_FIELD': True,
            'OUTPUT': parameters['DirectionDistanceOutput']
        }
        outputs['FieldCalculatorDirection'] = processing.run('qgis:fieldcalculator', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        results['DirectionDistanceOutput'] = outputs['FieldCalculatorDirection']['OUTPUT']
        return results

    def name(self):
        return 'Distance and Direction from Point'

    def displayName(self):
        return 'Distance and Direction from Point'

    def group(self):
        return ''

    def groupId(self):
        return ''

    def createInstance(self):
        return DistanceAndDirectionFromPoint()
